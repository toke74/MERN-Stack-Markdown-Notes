# ðŸ§¾ Multi-Vendor eCommerce Backend Requirements (User, Vendor, Order, Product, Payment)

# 1. User Registration Requirements

1. Get user input from `req.body` (name, email, password).
2. Check if a user with the given email already exists in the database.
3. If user exists, throw a 400 error: "User already exists with this email."
4. If user does not exist:
   - Hash the password.
   - Create new user in MongoDB.
5. Generate email verification code/token.
6. Send activation email to user's email with verification link or code.
7. Return status 201 with a message: "User registered successfully. Please verify your email."

```js
//import modules
import jwt from "jsonwebtoken";
import crypto from "crypto";

//import local files
import User from "../models/UserModel.js";
import ErrorHandler from "../utils/errorHandler.js";
import tryCatchAsyncErrorHandlers from "../middleware/tryCatchAsyncErrorHandlers.js";

// @desc    Register user
// @route   POST /api/v1/user/register
// @access  Public
export const registerUser = tryCatchAsyncErrorHandlers(
  async (req, res, next) => {
    // 1. Get user input from req.body (name, email, password).
    const { name, email, password } = req.body;

    //2. Check if a user with the given email already exists in the database.
    const isUserExist = await User.findOne({ email });

    //3. If user exists, throw a 400 error: "User already exists with this email."
    if (isUserExist) {
      return next(
        new ErrorHandler("User already exists with this email.", 400)
      );
    }

    //4. If user does not exist:- Create new user in MongoDB.
    const user = await User.create({
      name,
      email,
      password,
      provider: "Local",
    });

    //Steps 5, 6 and 7 will be complted after  ejs and nodemailer setup

    //5. Generate email verification code/token.

    //6. Send activation email to user's email with verification link or code.

    //7. Return status 201 with a message: "User registered successfully. Please verify your email."
  }
);
```

## 1.1. To send OTP to user email, Generate 4 digit OTP and activation token

1. In utils folder create generateTokens.js file
2. import jwt and "dotenv/config.js to the file
3. create Activation Token arrow function
4. In side the arrow function Generate random 4 digit number as activation code
5. Sign the Activation Code with jwt
6. return the the signed token and activation code

```js
import jwt from "jsonwebtoken";
import "dotenv/config.js";

//create Email Verification Token
export const createEmailVerificationToken = (id) => {
  //Generate random 4 digit number
  const EmailVerificationCode = Math.floor(
    1000 + Math.random() * 9000
  ).toString();

  //Sign the Activation Code with jwt
  const EmailVerificationToken = jwt.sign(
    {
      id,
      EmailVerificationCode,
    },
    process.env.JWT_EMAIL_VERIFICATION_SECRET,
    {
      expiresIn: process.env.JWT_EMAIL_VERIFICATION_EXPIRES,
    }
  );

  return { EmailVerificationCode, EmailVerificationToken };
};
```

## 1.2. Create email format to send OTP

1. In mails folder create header.ejs file inside it create header welcome text by using html and css

```html
<div
  style="
    background: linear-gradient(90deg, #1a2e66, #7f00ff);
    padding: 30px 0;
    text-align: center;
    font-family: 'Poppins', Arial, sans-serif;
    color: white;
  "
>
  <img
    src="https://yourdomain.com/path-to-your-logo.png"
    alt="ShopOrbit Logo"
    style="height: 60px; margin-bottom: 10px"
  />
  <h1 style="margin: 0; font-size: 28px">
    Welcome to <span style="color: #f37022">ShopOrbit</span>
  </h1>
  <p style="margin: 5px 0 0; font-size: 16px">Every product delivered to you</p>
</div>
```

2. In mails folder create footer.ejs file inside it create a footer element by using html and css

```html
<div
  style="
    background: linear-gradient(90deg, #1a2e66, #7f00ff);
    padding: 30px 0;
    text-align: center;
    font-family: 'Poppins', Arial, sans-serif;
    color: #ffffff;
    font-size: 14px;
  "
>
  <p style="margin: 0 0 8px">Have questions? We're here to help!</p>
  <p style="margin: 0">
    Contact us at
    <a
      href="mailto:support@shoporbit.com"
      style="color: #f37022; text-decoration: none"
    >
      support@shoporbit.com
    </a>
  </p>
</div>
```

3. In mails folder create welcome.ejs file inside it combine the two the above files and body elements

```html
<%- include('./header.ejs') %>

<div
  style="
    margin: 0 auto;
    max-width: 720px;
    padding: 30px 0;
    font-family: 'Poppins', Arial, sans-serif;
    color: #1c1c1e;
  "
>
  <p style="font-size: 16px">Hello <%= name %>,</p>

  <p style="font-size: 16px; line-height: 1.6">
    Welcome to <strong>ShopOrbit</strong>! Thank you for registering. To
    activate your account, please use the following activation code:
  </p>

  <h2
    style="
      font-size: 28px;
      color: #f37022;
      background-color: #f8f8f8;
      padding: 12px 24px;
      border-radius: 8px;
      text-align: center;
      width: fit-content;
      margin: 20px auto;
    "
  >
    <%= message %>
  </h2>

  <p style="font-size: 16px; line-height: 1.6; text-align: center">
    Please enter this code on the activation page within the next 10 minutes.
  </p>

  <p
    style="
      font-size: 14px;
      color: #666666;
      line-height: 1.6;
      text-align: center;
    "
  >
    If you did not register for a ShopOrbit account, you can safely ignore this
    email.
  </p>
</div>

<%- include('./footer.ejs') %>
```

## 1.3 Using Google App Passwords for Nodemailer

If you're using Google with third-party apps like Nodemailer, direct login with your email password may fail due to enhanced security policies. Instead, generate an App Password.

### To generate an App Password on Google Account:

1. Go to Manage Your Google Account ![Manage Your Google Account](/Images/Google%20Account/Manage%20Your%20Google%20acount.png)
2. Then Go to Google Account Settings, Under "Security section" enable 2-Step Verification.
   ![](/Images/Google%20Account/2.png)

   ![](/Images/Google%20Account/3.png)

   ![](/Images/Google%20Account/5.png)

   ![](/Images/Google%20Account/6.png)

3. After enabling 2-Step Verification, return to the Security section in your Google account. Look for App Passwords option under Security section, if not found there, search it as App Passwords in Search bar in Google account ![app Password](/Images/Google%20Account/1.png)

4. If promoted to Sign in to your account again to verify your identity, go head verify yourself.
5. Type your project name in App name field and click on create.
   ![](/Images/Google%20Account/7.png)

   ![](/Images/Google%20Account/8.png)

6. Copy the generated 16-character password. This is your App Password.
7. Use the generated app password in your `.env` file for Nodemailer.

## 1.4 To Send the activation email to user

### Dependencies

1. Built-in Node.js modules: path, url
2. Nodemailer: For sending emails
3. Dotenv: For environment variable management
4. Ejs: For rendering email templates

### 1. Built-in Node.js modules: path, url

#### In Node.js when using ECMAScript (ES) modules.

`import path from "path";` :- This line imports the built-in Node.js path module, which provides utilities for working with file and directory paths.

`import { fileURLToPath } from "url"; `:- This line imports the fileURLToPath function from the built-in Node.js url module. This function is used to convert a file:// URL into a platform-specific file path.

`import { dirname } from "path"; `:- This line specifically imports the dirname function from the path module. This function extracts the directory name from a given path.

`const __filename = fileURLToPath(import.meta.url);` :- `import.meta.url` is a special property available in ES modules that provides the full URL of the current module file (e.g., file:///path/to/your/file.js).

`fileURLToPath(import.meta.url)` converts this URL into a standard file path string (e.g., /path/to/your/file.js), which is then assigned to the `__filename` constant. This \*\*filename effectively serves the same purpose as the \_\_filename global variable in CommonJS modules.

`const __dirname = dirname( __filename); `:-

- dirname(\_\_filename) uses the dirname function from the path module to extract the directory part from the \*\*filename path.
- The resulting directory path is assigned to the \*\*dirname constant, which then functions similarly to the \*\*dirname global variable found in CommonJS modules.

  In summary, this code provides a workaround to access the current file's full path ( \_\_filename) and its directory path ( \_\_dirname) within an ES module environment, as these global variables are not directly available in ES modules like they are in CommonJS.

### 2. Nodemailer: For sending emails

##### 2.1 To send email we use nodemailer package.

`Nodemailer` is a module for Node.js applications to allow easy as cake email sending.

This module provides functionality for sending emails using Nodemailer with EJS templates. It's designed to be used in a Node.js application for sending templated emails with dynamic content.

Nodemailer is a popular Node.js module for sending emails. It simplifies the process of sending emails from Node.js applications by providing a straightforward API and supporting various email features and transport methods. Key features include security, Unicode support, and the ability to send different types of emails (plain text, HTML, with attachments).

##### 2.2 Nodemailer Installation:

You can install it using npm: npm install nodemailer

##### 2.3 Nodemailer Transporter:

A transporter object is created to handle the email sending process. It requires configuration with details like the email service (e.g., Gmail, Outlook), authentication credentials (user, password or OAuth2), and optional settings.

##### 2.4 Message Options:

The mailOptions object specifies the email details, including sender, recipients (to, cc, bcc), subject, and content (text and/or HTML).

##### 2.5 Sending Emails:

The transporter.sendMail() method sends the email, taking the mailOptions and a callback function to handle success or errors.

##### 2.6 Security:

Nodemailer emphasizes security and avoids Remote Code Execution (RCE) vulnerabilities. It's recommended to use environment variables for sensitive information like credentials.

##### 2.7 OAuth2 Authentication:

For services like Gmail, OAuth2 authentication is recommended for enhanced security. This involves setting up an OAuth 2.0 client ID and secret, and obtaining a refresh token.

##### 2.8 Gmail Specifics:

Gmail requires 2-Step Verification and App Passwords for use with Nodemailer.

##### 2.9 Error Handling:

Nodemailer provides error handling through the callback function when sending emails

##### 2.10 Nodemailer Transport Configuration

```js
 nodemailer.createTransport({
  host: process.env.SMTP_HOST,
  port: parseInt(process.env.SMTP_PORT || "587"),
  service: process.env.SMTP_SERVICE,
  auth: {
    user: process.env.SMTP_MAIL,
    pass: process.env.SMTP_PASSWORD,
  },
});"
```

This code creates a transporter object using Nodemailer, which is essentially a connection to an SMTP (Simple Mail Transfer Protocol) server that will be used to send emails. Here's a detailed breakdown:

##### 2.11 Core Components

`nodemailer.createTransport()` :-
This is the main method from the Nodemailer library that creates a reusable mail transporter object. All email sending operations will use this configured transporter.

##### 2.12 Configuration Options

` 1. host`

```js
host: process.env.SMTP_HOST;
```

-Specifies the SMTP server hostname (e.g., "smtp.gmail.com" or "smtp.mail.yahoo.com")
-Retrieved from environment variables for security (keeps credentials out of code)
-Example value might be: "smtp.gmail.com"

`2. port`

```js
port: parseInt(process.env.SMTP_PORT || "587");
```

- Defines the port number for the SMTP connection
- Uses a fallback value of "587" if SMTP_PORT isn't set in environment
- parseInt() converts the string to a number (SMTP requires numeric port)
- Port 587 is the standard port for SMTP submission with TLS encryption

* Other common ports:

  - 465 for SMTPS (deprecated but still used)
  - 25 for unencrypted SMTP (not recommended)

- Port Selection:

  - Using port 587 (with STARTTLS) is more secure than port 25

  - Port 465 (SMTPS) is also secure but less commonly used now

`3. service`

```js
service: process.env.SMTP_SERVICE;
```

- Optional but recommended for well-known providers

- Can be used instead of host and port for popular services

* Nodemailer knows default settings for services like:

  - "Gmail"

  - "Yahoo"

  - "Hotmail"

  - "Outlook"

  - "iCloud"

* If both service and host/port are provided, service takes precedence
* Example usage in .env

```js
SMTP_SERVICE = Gmail;
```

or in nodemailer

```js
{
  service: "Gmail",
}
```

`4. auth`

```js
      auth: {
        user: process.env.SMTP_MAIL,
        pass: process.env.SMTP_PASSWORD,
      }
```

- Contains authentication credentials for the SMTP server

- user: The email account username (typically your email address )

- pass: The password or app-specific password for the account of your email

- Both values are securely loaded from environment variables

* For Gmail, the pass value you might need to:

  - Use an "App Password" if 2FA is enabled

  - Allow "Less secure apps" if using basic authentication, other than app password

`Example Configuration`

```js
{
    host: "smtp.gmail.com",
    port: 587,
    service: "Gmail",
    auth: {
          user: "your.email@gmail.com",
          pass: "your-app-specific-password"
       }
}
```

### 3. Dotenv: For environment variable management

`Example Configuration`

For a Gmail account in .env file,

```js
    SMTP_HOST=smtp.gmail.com
    SMTP_PORT=587
    SMTP_SERVICE=Gmail
    SMTP_MAIL=your.email@gmail.com
    SMTP_PASSWORD=your-app-password-you-get-it-from-Google
```

### 4. Ejs: For rendering email templates

#### What is EJS

EJS, or Embedded JavaScript templating, is a simple templating language that lets you generate HTML markup with plain JavaScript. It allows you to embed JavaScript code directly within HTML files, making it easier to create dynamic web pages.

#### What it does:

EJS enables you to create HTML templates where you can insert dynamic content and logic written in JavaScript.

#### How it works:

EJS uses special tags to identify JavaScript code within HTML. These tags can be used to output variables, control flow (like loops and conditionals), and even include other templates.

#### Use cases:

EJS is commonly used in Node.js applications, especially with frameworks like Express.js, to generate dynamic web pages by combining static HTML with data from the server.

#### Ejs Methodes ejs.renderFile() and ejs.render()

Both methods are used for rendering EJS templates, but they work differently

##### 1. ejs.renderFile()

- Purpose: Renders an EJS template stored in a file.
- Usage: Best when templates are stored in separate .ejs files.

`Syntax:`

With callback function:

```js
ejs.renderFile(filename, data, options, callback);
```

or with async/await :

```javascript
const html = await ejs.renderFile(filename, data, options);
```

Parameters:-

- filename: The path to the EJS template file to be rendered.
- data: An object containing the data to be passed to the template. This data can then be accessed and used within the EJS file to dynamically generate content.
- options: An optional object for configuring rendering options (e.g., caching, filename for includes).
- callback: A function that will be called once the rendering is complete, receiving either an error object or the rendered HTML string.

`Key Features:`

- Works directly with file paths.
- Supports asynchronous operations (better for production).
- Automatically reads the file content.
- Can use caching for better performance.

`Example:`

```javascript
const html = await ejs.renderFile(path.join(__dirname, "templates/email.ejs"), {
  name: "John",
});
```

##### 2. ejs.render()

- Purpose: Renders an EJS template from a string (not a file).
- Usage: Best for inline templates or dynamically generated strings.

`Syntax:`

With callback function

```javascript
ejs.render(templateString, data, options, callback);
```

or with async/await:

```javascript
const html = await ejs.render(templateString, data, options);
```

`Key Features:`

- Works with raw template strings (no file needed).
- Synchronous by default (unless using async option).
- Faster for small, dynamic templates.

`Example:`

```javascript
const template = `<h1>Hello <%= name %>!</h1>`;
const html = ejs.render(template, { name: "John" });
```

### In side utils folder create `sendEmail.js` file, inside it write eamil sending code

```js
import nodemailer from "nodemailer";
import ejs from "ejs";
import path from "path";
import { fileURLToPath } from "url";
import { dirname } from "path";
import "dotenv/config";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const transporter = nodemailer.createTransport({
  host: process.env.SMTP_HOST,
  port: parseInt(process.env.SMTP_PORT || "587"),
  service: process.env.SMTP_SERVICE,
  auth: {
    user: process.env.SMTP_MAIL,
    pass: process.env.SMTP_PASSWORD,
  },
});

const sendEmail = async (options) => {
  const { email, subject, message, name, ejsUrl } = options;

  try {
    // Render EJS template
    const data = await ejs.renderFile(
      path.join(__dirname, `../mails/${ejsUrl}`),
      { email, message, name }
    );

    // Send email
    const mailOptions = {
      from: process.env.SMTP_MAIL,
      to: email,
      subject,
      html: data,
    };

    await transporter.sendMail(mailOptions);

    console.log(`Email sent successful to ${email} `);

    return { success: true, email };
  } catch (error) {
    console.error("Email sending failed:", error);
    throw error; // Re-throw to let caller handle it
  }
};

export default sendEmail;
```

## Now we are back to Register User Controller

To finish step 5, 6 and 7

### In step 5. Generate email verification code/token.

We already generated Verification code inside `utils` folder/generateTokens.js, then import the method in side register user controller file.

```js
//import modules
import jwt from "jsonwebtoken";
import crypto from "crypto";

//import local files
import User from "../models/UserModel.js";
import ErrorHandler from "../utils/errorHandler.js";
import tryCatchAsyncErrorHandlers from "../middleware/tryCatchAsyncErrorHandlers.js";
import { createEmailVerificationToken } from "../utils/generateTokens.js";
import sendEmail from "../utils/sendEmail.js";

// @desc    Register user
// @route   POST /api/v1/user/register
// @access  Public
export const registerUser = tryCatchAsyncErrorHandlers(
  async (req, res, next) => {
    // 1. Get user input from req.body (name, email, password).
    const { name, email, password } = req.body;

    //2. Check if a user with the given email already exists in the database.
    const isUserExist = await User.findOne({ email });

    //3. If user exists, throw a 400 error: "User already exists with this email."
    if (isUserExist) {
      return next(
        new ErrorHandler("User already exists with this email.", 400)
      );
    }

    //4. If user does not exist:- Create new user in MongoDB.
    const user = await User.create({
      name,
      email,
      password,
      provider: "Local",
    });

    //5. Generate email verification code/token.
    const emailVerificationToken = createEmailVerificationToken(user._id);
    const { EmailVerificationCode } = emailVerificationToken;
    const message = EmailVerificationCode;
    const ejsUrl = `welcome.ejs`;

    //6. Send activation email to user's email with verification link or code.
    try {
      await sendEmail({
        email,
        subject: "Verify your email",
        message,
        name,
        ejsUrl,
      });

      //7. Return status 201 with a message: "User registered successfully. Please verify your email.
      res.status(201).json({
        success: true,
        message: `Please check your email ${user.email} to activate your account!`,
        EmailVerificationToken: emailVerificationToken.EmailVerificationToken,
      });
    } catch (error) {
      return next(new ErrorHandler(error.message, 400));
    }
  }
);
```

# 2. Create User Route

Now we have register user controller function and we can now add this register user controller function to route file. Inside routes folder create `userRoute.js` file. In this file write âœï¸ the following code.

```js
import express from "express";
import { registerUser } from "../controllers/UserController.js";

const userRouter = express.Router();

// Create user route
userRouter.post("/register", registerUser);

export default userRouter;
```

# 3. Adding user Route middleware to app.js file

Inside app.js file. In this file write âœï¸ the following code.

```js
import userRouter from "./routes/userRoute.js";

//routes Middlewares
app.use("/api/v1/user", userRouter);
```

# 4. Verify User Email

Verifying a user's email after registering to an app refers to a security and validation process designed to confirm that the email address provided during registration is legitimate and accessible by the user who registered it. This process typically involves the following steps:

`Sending a Confirmation Email:`

After a user registers, the app automatically sends an email to the address they provided. This email usually contains a unique a one-time verification code.

`User Action:`

The user must then access their email inbox, locate the confirmation email, and enter the provided code back into the app.

`Account Activation/Verification:`

Once the user completes the required action ( entering the code), the app confirms that the email address is valid and owned by the user. This typically activates their account or grants them full access to the app's features.

## 4.1 User Activation/Verification requirements

1. Get activation code and activation token from req.body,
2. Verify activation token by using jwt.verify
3. If the activation token not valid , throw the error to the client
4. If the activation token is valid, check if activation code match which is decoded from activation token.
5. If not match , throw the error to the client
6. If match, find user in DB by using its ID, which is decoded from activation token.
7. If user not exist in DB, throw the error to the client
8. If user exist and isVerified field is true , throw the error to the client stating that "Your email is verified, Please login"
9. If user exist and isVerified field is false, update users' DB `isVerified: true` and then send success message to client.

## 4.2 User Activation/Verification Code

Inside `userController.js` file, write âœï¸ the following code to Activate/Verify user.

```js
// @desc    Activate user
// @route   POST /api/v1/user/activate_user
// @access  Public
export const activateUser = tryCatchAsyncErrorHandlers(
  async (req, res, next) => {
    const { Verification_token, verification_code } = req.body;

    //verify toke
    const decoded = jwt.verify(
      Verification_token,
      process.env.JWT_EMAIL_VERIFICATION_SECRET
    );

    // if Eamail Verification code not valid, throw error
    if (verification_code !== decoded.EmailVerificationCode) {
      return next(new ErrorHandler("Invalid activation code", 400));
    }

    //if Eamil Verification code is valid, find user
    const isUserExist = await User.findOne({ _id: decoded.id });

    // if user not exist, throw the error
    if (!isUserExist) {
      return next(new ErrorHandler("User not exist ", 400));
    }

    //if user exist and isVerified field is true, throw the error ask user to login
    if (isUserExist.isVerified) {
      return next(
        new ErrorHandler("Your email is verified, Please login ", 400)
      );
    }

    // if user  exist and  isVerified field is false, update the user as verified
    const user = await User.findOneAndUpdate(
      { _id: decoded.id },
      { isVerified: true }
    );

    // Then send success message to client
    res.status(201).json({
      success: true,
    });
  }
);
```

## 4.3 Add Verify User Route to user Route (userRoute.js)

Now we have activate user controller function and we can now add this activate user controller function to route file.

Inside `userRoute.js` file, write âœï¸ the following code.

```js
import express from "express";
import { registerUser, activateUser } from "../controllers/UserController.js";

const userRouter = express.Router();

// Create user route
userRouter.post("/register", registerUser);

// activate user route
userRouter.post("/activate_user", activateUser);

export default userRouter;
```

# 5. Access token and Refresh token for User Login

In MERN stack user login, JSON Web Tokens (JWTs) are commonly used for authentication, often employing both an access token and a refresh token for enhanced security and a better user experience.

## 5.1 Access token and Refresh token

`Access tokens and refresh tokens`
are both used in authentication and authorization processes to balance security and user experience. Access tokens grant temporary access to restricted resources, while Refresh tokens extend the lifespan of access tokens

`Access tokens`
These digital assets allow users to access resources without repeated login requests. They are usually valid for a few minutes or hours and include security features like signatures. Access tokens are used for passwordless auth solutions, accessing shared resources, and authenticating to access or modify files owned by others.

`Refresh tokens`
These tokens are used to obtain new access tokens once the current ones expire. When an access token expires, the user can use a refresh token to make a request to get a new access token without logging in again. This process can continue until the refresh token itself expires or is revoked.

Refresh tokens can have a longer lifetime than access tokens. For example, in the Microsoft identity platform, the default lifetime for refresh tokens is 24 hours for single page apps and 90 days for all other scenarios. Refresh tokens can also be more secure than access tokens. If an access token is compromised, the thief will only have until the token expires to cause damage. If a refresh token is stolen, it can be placed on a blacklist to prevent it from generating any new access tokens.

### 1. Access Token:

The access token is a short-lived token that grants immediate access to protected resources. It contains information about the user and their permissions.

`Generation:`

Upon successful user login and credential validation on the server (Node.js/Express.js), a new access token is generated using a secret key.

`Storage:`

Never Store Acccess Tokens in localStorage but Store access token in memory (not localStorage!)

`Usage:`

The client-side (React) includes this access token in the Authorization header of every subsequent request to protected routes.

`Validation:`

The server validates the access token on each request using middleware. If valid, the request is processed; otherwise, access is denied.

`Lifespan:`

Access tokens are designed to be short-lived (e.g., 15 minutes to an hour) to minimize the impact if compromised.

### 2. Refresh Token:

The refresh token is a long-lived token used to obtain a new access token when the current one expires, without requiring the user to re-enter their credentials.

`Generation:`

A refresh token is also generated upon successful login, alongside the access token.

`Storage:`

Never Store Refresh Tokens in localStorage or sessionStorage. Extremely vulnerable to XSS (Cross-Site Scripting) attacks.
JavaScript can read localStorage, so any malicious script can steal tokens. If your React app has an XSS vulnerability, attackers get permanent access. So use in HTTP-only cookies, to mitigate XSS (Cross-Site Scripting) attacks.

#### `Secure Storage Options for Refresh Tokens`

##### Option 1: HTTP-Only Cookies (Recommended)

`Advantages:`

- mInvisible to JavaScript (immune to XSS)

- Automatically sent with requests

- Can set expiration and security flags

```js
// Backend (Express.js) - Setting the cookie
res.cookie("refreshToken", refreshToken, {
  httpOnly: true, // Cannot be read by JavaScript
  secure: true, // Only sent over HTTPS
  sameSite: "Strict", // Prevents CSRF
  maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
});
```

##### Option 2: In-Memory (For SPAs)

- Store refresh token only in JavaScript memory (not localStorage)

- Disappears when tab closes

- Disadvantage: User must re-login after page refresh

```js
let refreshToken = null; // In-memory storage

// After login:
refreshToken = response.data.refreshToken;
```

`Usage:`

When an access token expires (indicated by a 401 Unauthorized error from the server), the client sends the refresh token to a dedicated "refresh" endpoint on the server.

`Validation and Renewal:`

The server validates the refresh token. If valid, it issues a new access token (and optionally a new refresh token) to the client. If the refresh token is invalid or expired, the user is typically logged out and redirected to the login page.

`Lifespan:`
Refresh tokens have a longer lifespan than access tokens (e.g., days or weeks).

## 5.2 How Refresh token and Access token works with JWT

1. Generate Access token and Refresh token
2. Send them to client by http-only cookie
3. Every time the client want to access protected resources, sends resources end point along with access token
4. Access token usually 5min to a hour, will expire fast need to refreshed. So to issue new access token, we need to setup refresh token end point.
5. From refresh token end point we Generate access token and send it to client by http-only cookies.
6. To Verify access token is valid, we make middleware to protect every protected route.

## 5.3 Token Workflow in MERN Stack

### 1. âœ… User Login Flow

#### Backend (Node.js/Express):

- User sends email & password to /api/auth/login
- Server verifies credentials.

* If correct:

        - Generate:

                * Access Token (JWT, short-lived)
                * Refresh Token (JWT or random string, long-lived)

        - Send:

                * Access token in response (or HTTP-only cookie)
                * Refresh token in HTTP-only cookie

#### Frontend (React):

- Store access token (e.g., in memory or Redux).
- Use it to call protected APIs.

### 2. ðŸ”„ Access Token Expired? Use Refresh Token

#### Frontend:

- If an API call fails with 401 (unauthorized), automatically:

  - Send refresh token (in HTTP-only cookie) to /api/auth/refresh
  - Get a new access token
  - Retry original request

#### Backend:

- Verify refresh token
- If valid, issue new access token
- Optionally rotate refresh token (for extra security)

### 3. ðŸšª User Logout

- Clear refresh token from HTTP-only cookie
- Invalidate the refresh token (if stored in DB)

## 5.4 Steps to Implement Access and Refresh Token

### Step 1. Create variable in .env file

```js
ACCESS_TOKEN = 568b6620639fdf54 //this is example access token
REFRESH_TOKEN = 203566598d577e1  //this is example refresh token

ACCESS_TOKEN_EXPIRATION = 15m // Access token valid for 15 minutes
REFRESH_TOKEN_EXPIRATION = 7d // Refresh token valid for 7 days

```

`Explanation:`

ACCESS_TOKEN_EXPIRATION:

- Value is in minutes. Example: 15m means the access token will expire in 15 minutes.

REFRESH_TOKEN_EXPIRATION:

- Value is in days. Example: 7d means the refresh token will expire in 7 days.

#### To generate a string for ACCESS_TOKEN and REFRESH_TOKEN

- use the following command in node terminal

```js
  $ node
  Welcome to Node.js v20.4.0.
  Type ".help" for more information.

  > require('node:crypto').randomBytes(8).toString('hex')

  '568b6620639fdf54'
```

### Step 2. Generate Access token & Refresh token

In side utils folder / inside generateTokens.js file write âœï¸ a code to generate both tokens.

```js
import jwt from "jsonwebtoken";
import "dotenv/config.js";

// Accessing environment variables
const accessTokenExpiration = process.env.ACCESS_TOKEN_EXPIRATION || "15m"; // Fallback to 15 minutes
const refreshTokenExpiration = process.env.REFRESH_TOKEN_EXPIRATION || "30d"; // Fallback to 30 days

// Generating Access Token
export const generateAccessToken = (userId) => {
  return jwt.sign({ id: userId }, process.env.ACCESS_TOKEN_SECRET, {
    expiresIn: accessTokenExpiration,
  });
};

// Generating Refresh Token
export const generateRefreshToken = (userId) => {
  return jwt.sign({ id: userId }, process.env.REFRESH_TOKEN_SECRET, {
    expiresIn: refreshTokenExpiration,
  });
};

//create Email Verification Token
export const createEmailVerificationToken = (id) => {
  //Generate random 4 digit number
  const EmailVerificationCode = Math.floor(
    1000 + Math.random() * 9000
  ).toString();

  //Sign the Activation Code with jwt
  const EmailVerificationToken = jwt.sign(
    {
      id,
      EmailVerificationCode,
    },
    process.env.JWT_EMAIL_VERIFICATION_SECRET,
    {
      expiresIn: process.env.JWT_EMAIL_VERIFICATION_EXPIRES,
    }
  );

  return { EmailVerificationCode, EmailVerificationToken };
};
```

### Step 3. Write helper function to send Access token & Refresh token to the client

Inside utils folder, create `sendTokensToClient.js` file and write âœï¸ the following code

```js
import "dotenv/config.js";
import { generateAccessToken, generateRefreshToken } from "./generateTokens.js";
import tryCatchAsyncErrorHandlers from "../middleware/tryCatchAsyncErrorHandlers.js";

// Function to send tokens via cookies
export const sendTokensToClient = tryCatchAsyncErrorHandlers(
  async (user, statusCode, res) => {
    const accessToken = generateAccessToken(user.id);
    const refreshToken = generateRefreshToken(user.id);

    // Remove password field
    const { password, ...userWithoutPassword } = user.toObject(); // Convert to plain object and exclude password

    console.log(user);

    // Options for Access Token Cookie
    const accessTokenCookieOptions = {
      httpOnly: true, // Accessible only by the web server
      secure: process.env.NODE_ENV === "production", // Send over HTTPS only in production
      sameSite: "strict", // Prevent CSRF attacks
      maxAge: 15 * 60 * 1000, // 15 minutes in milliseconds
    };

    // Options for Refresh Token Cookie
    const refreshTokenCookieOptions = {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      sameSite: "strict",
      maxAge: 30 * 24 * 60 * 60 * 1000, // 30 days in milliseconds
    };

    // Set cookies
    res.cookie("accessToken", accessToken, accessTokenCookieOptions);
    res.cookie("refreshToken", refreshToken, refreshTokenCookieOptions);

    // Optionally, send tokens in the response body as well
    res.status(statusCode).json({
      success: true,
      user: userWithoutPassword,
    });
  }
);
```

# 6. User Login

## 6.1 User Login Requirements

1. Get user email and password from req.body
2. Check email and password exist or not
3. Find user in DB, If not exist in DB, throw the error to client
4. If exist, include password in query (`select: +password`)
5. Check if the user is verify their email or not
6. If user not verified their email address, Send activation link to the user
7. If user verified their email address, Check user password matches by using jwt.verify
8. If user password not match, throw the error to client.
9. If user password matches, send cookie of accessToken and refreshToken
   And also send res.json accessToken to client.

## 6.2 user Login Code

```js
// @desc    Login user
// @route   POST /api/v1/user/login
// @access  Public
export const loginUser = tryCatchAsyncErrorHandlers(async (req, res, next) => {
  //Get email and password from user
  const { email, password } = req.body;

  //check email and password empty or not
  if (!email || !password) {
    return next(new ErrorHandler("Please provide an email and password", 400));
  }

  // find  user in DB
  const user = await User.findOne({ email }).select("+password");

  // if user not exist in DB throw error
  if (!user) {
    return next(new ErrorHandler("Invalid credentials", 401));
  }

  //if user exist  in DB, Check if the user  verified their email
  if (!user.isVerified) {
    //If user not verified their email address,  Send activation link to the user

    const emailVerificationToken = createEmailVerificationToken(user._id);
    const { EmailVerificationCode } = emailVerificationToken;
    const message = EmailVerificationCode;
    const ejsUrl = `welcome.ejs`;
    const name = user.name;

    //send activation code to user email
    try {
      await sendEmail({
        email,
        subject: "Verify your email",
        message,
        name,
        ejsUrl,
      });

      return res.status(200).json({
        success: false,
        message: `Please check your email ${user.email} to activate your account!`,
        EmailVerificationToken: emailVerificationToken.EmailVerificationToken,
      });
    } catch (error) {
      return next(new ErrorHandler(error.message, 400));
    }
  }

  //Check user password matches
  const isMatch = await user.comparePassword(password);

  // if not match, throw error
  if (!isMatch) {
    return next(new ErrorHandler("Invalid credentials", 401));
  }

  //import methods to generate access Token and refresh token
  sendTokensToClient(user, 200, res);
});
```

## 6.3 Create user login Route

Now we have login user controller function and we can now add this login user controller function to route file.

Inside userRoute.js file, write âœï¸ the following code.

```js
import express from "express";
import {
  registerUser,
  activateUser,
  loginUser,
} from "../controllers/UserController.js";

const userRouter = express.Router();

// Create user route
userRouter.post("/register", registerUser);

// activate user route
userRouter.post("/activate_user", activateUser);

// Login user route
userRouter.post("/login", loginUser);

export default userRouter;
```

# 7. Resend Activation code

## 7.1 Resend Activation code Requirement

1. Get user's email from client by req.body
2. Find user in db by its email
3. If user not exist, throw the error
4. If user exist and isVerified field is true, throw the error ask user to login
5. If user exist and isVerified field is false, Send activation code to the user
6. Send activation code to user email
7. Finally send success message to client

## 7.2 Resend Activation code

```js
// @desc    Resend Activation code
// @route   POST /api/v1/user/resend_activation_code
// @access  Public
export const resendActivationCode = tryCatchAsyncErrorHandlers(
  async (req, res, next) => {
    //Get user email from client by req.body
    const { email } = req.body;

    //find user in db by its email
    const user = await User.findOne({ email });

    // if user not exist, throw the error
    if (!user) {
      return next(new ErrorHandler("User not exist ", 400));
    }

    //if user exist and isVerified field is true, throw the error ask user to login
    if (user.isVerified) {
      return next(
        new ErrorHandler("Your email is verified, Please login ", 400)
      );
    }

    // if user   exist and  isVerified field is false, Send activation code to the user
    const emailVerificationToken = createEmailVerificationToken(user._id);
    const { EmailVerificationCode } = emailVerificationToken;
    const message = EmailVerificationCode;
    const ejsUrl = `welcome.ejs`;
    const name = user.name;

    //send activation code to user email
    try {
      await sendEmail({
        email,
        subject: "Verify your email",
        message,
        name,
        ejsUrl,
      });

      //finally send success message to client
      res.status(200).json({
        success: false,
        message: `Please check your email ${user.email} to activate your account!`,
        EmailVerificationToken: emailVerificationToken.EmailVerificationToken,
      });
    } catch (error) {
      return next(new ErrorHandler(error.message, 400));
    }
  }
);
```

## 7.3 Create Resend Activation code Route

Now we have Resend Activation code controller function and we can now add this Resend Activation code controller function to route file.

Inside userRoute.js file, write âœï¸ the following code.

```js
import express from "express";
import {
  registerUser,
  activateUser,
  loginUser,
  resendActivationCode,
} from "../controllers/UserController.js";

const userRouter = express.Router();

// Create user route
userRouter.post("/register", registerUser);

// activate user route
userRouter.post("/activate_user", activateUser);

// Login user route
userRouter.post("/login", loginUser);

// Resend activation code route
userRouter.post("/resend_activation_code", resendActivationCode);

export default userRouter;
```

# 8. Update Access Token

## 8.1 Update Access Token Requirements

1. Get refresh token from cookies, req.cookies.refresh_token
2. Check whether the refresh token is empty or not?
3. If empty, throw error
4. If not empty, check the validity of the refresh token. By using jwt.verify() method
5. If not valid, throw error
6. If it is valid, find user from DB by using ID. We get user ID from decoded refresh token
7. If user not exist in DB by that ID, throw error
8. If user exist in DB, then put user object on req.user so that access by middlewares
9. Import method to generate access token and refresh token to send it by cookie and Json from utils folder inside generateTokes.js file.

## 8.2) Update Access Token code

```js
// @desc    Update Access Token
// @route   GET /api/v1/user/refresh_Token
// @access  Public
export const updateAccessToken = tryCatchAsyncErrorHandlers(
  async (req, res, next) => {
    //Get refresh token from cookies, every time client send request. the cookie send along with the request.
    const refresh_token = req.cookies.refreshToken;

    // Check whether the refresh token is empty or not
    if (!refresh_token) {
      return next(
        new ErrorHandler("Refresh token not found. Please login again.", 401)
      );
    }
    // Verify the validity of the refresh token
    let decoded;
    try {
      decoded = jwt.verify(refresh_token, process.env.REFRESH_TOKEN_SECRET);
    } catch (err) {
      return next(
        new ErrorHandler("Invalid refresh token. Please login again.", 401)
      );
    }

    // If valid, find user by decoded ID from the token
    const user = await User.findById(decoded.id);

    //If user not exist, throw error
    if (!user) {
      return next(new ErrorHandler("User not found. Please login again.", 404));
    }

    //Put user object on req.user for access by middleware
    req.user = user;

    //import methods to generate access Token and refresh token
    sendTokensToClient(user, 200, res);
  }
);
```

## 8.3) Create Update Access Token Route

Now we have Update Access Token code controller function and we can now add this Update Access Token code controller function to route file.

Inside userRoute.js file, write âœï¸ the following code.

```js
import express from "express";
import {
  registerUser,
  activateUser,
  loginUser,
  resendActivationCode,
  updateAccessToken,
} from "../controllers/UserController.js";

const userRouter = express.Router();

// Create user route
userRouter.post("/register", registerUser);

// activate user route
userRouter.post("/activate_user", activateUser);

// Login user route
userRouter.post("/login", loginUser);

// Resend activation code route
userRouter.post("/resend_activation_code", resendActivationCode);

// Update Access Token route
userRouter.get("/refresh_Token", updateAccessToken);

export default userRouter;
```

# 9. Logout User

## 9.1 logout User Requirements

1. Clear Cookies: The res.cookie() method clears the accessToken and refreshToken cookies by setting them to an empty value ("") and providing an expires date in the past.

2. Secure and HttpOnly: The cookies are configured to be httpOnly for security. They are also set to secure and sameSite depending on the environment.

3. Response: A success response is sent back to the client to indicate that the logout was successful.

4. Error Handling: If an error occurs, it is passed to the next() function to be handled by the error middleware.

## 9.2 Logout user code

```js
// @desc    Logout user
// @route   GET /api/v1/user/logout
// @access  Public
export const logoutUser = tryCatchAsyncErrorHandlers(async (req, res, next) => {
  res
    .cookie("accessToken", "", {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      sameSite: "Strict",
      expires: new Date(0), // Set expiry to past date
    })
    .cookie("refreshToken", "", {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      sameSite: "Strict",
      expires: new Date(0), // Set expiry to past date
    });
  //Send success message to client
  res.status(200).json({
    success: true,
    accessToken: "",
    message: "Logged out successfully",
  });
});
```

## 9.2 Create Logout user Route

```js
import express from "express";
import {
  registerUser,
  activateUser,
  loginUser,
  resendActivationCode,
  updateAccessToken,
  logoutUser,
} from "../controllers/UserController.js";

const userRouter = express.Router();

// Create user route
userRouter.post("/register", registerUser);

// activate user route
userRouter.post("/activate_user", activateUser);

// Login user route
userRouter.post("/login", loginUser);

// Resend activation code route
userRouter.post("/resend_activation_code", resendActivationCode);

// Update Access Token route
userRouter.get("/refresh_Token", updateAccessToken);

// logout route
userRouter.get("/logout", logoutUser);

export default userRouter;
```

## 6. Forgot Password Requirements

1. Get email from `req.body`.
2. Check if user exists.
3. Generate reset token and expiry.
4. Save to DB and send email with reset link.
5. Return 200 with message.

## 7. Reset Password Requirements

1. Get token and new password from request.
2. Find user by token and validate expiry.
3. Hash new password, update DB.
4. Return 200: "Password updated successfully".

## 8. Get User Profile Requirements

1. Use `req.user.id` to fetch user profile.
2. Return 200 with user data.

## 9. Update Profile Requirements

1. Get updated fields from `req.body`.
2. Update DB, verify if email changed.
3. Return 200 with updated user.

## 10. Change Password Requirements

1. Get old and new password.
2. Verify old password.
3. Hash and update new password.
4. Return 200.

## 11. Wishlist Requirements

1. Get productId.
2. Toggle add/remove from wishlist.
3. Return updated wishlist.

## 12. Address Management Requirements

- **Add/Update/Delete Address**
- Set default
- Return updated address list

```

```
