# üßæ Multi-Vendor eCommerce Backend Requirements (User, Vendor, Order, Product, Payment)

# 1. User Registration Requirements

1. Get user input from `req.body` (name, email, password).
2. Check if a user with the given email already exists in the database.
3. If user exists, throw a 400 error: "User already exists with this email."
4. If user does not exist:
   - Hash the password.
   - Create new user in MongoDB.
5. Generate email verification code/token.
6. Send activation email to user's email with verification link or code.
7. Return status 201 with a message: "User registered successfully. Please verify your email."

```js
//import modules
import jwt from "jsonwebtoken";
import crypto from "crypto";

//import local files
import User from "../models/UserModel.js";
import ErrorHandler from "../utils/errorHandler.js";
import tryCatchAsyncErrorHandlers from "../middleware/tryCatchAsyncErrorHandlers.js";

// @desc    Register user
// @route   POST /api/v1/user/register
// @access  Public
export const registerUser = tryCatchAsyncErrorHandlers(
  async (req, res, next) => {
    // 1. Get user input from req.body (name, email, password).
    const { name, email, password } = req.body;

    //2. Check if a user with the given email already exists in the database.
    const isUserExist = await User.findOne({ email });

    //3. If user exists, throw a 400 error: "User already exists with this email."
    if (isUserExist) {
      return next(
        new ErrorHandler("User already exists with this email.", 400)
      );
    }

    //4. If user does not exist:- Create new user in MongoDB.
    const user = await User.create({
      name,
      email,
      password,
      provider: "Local",
    });

    //Steps 5, 6 and 7 will be complted after  ejs and nodemailer setup

    //5. Generate email verification code/token.

    //6. Send activation email to user's email with verification link or code.

    //7. Return status 201 with a message: "User registered successfully. Please verify your email."
  }
);
```

## 1.1. To send OTP to user email, Generate 4 digit OTP and activation token

1. In utils folder create generateTokens.js file
2. import jwt and "dotenv/config.js to the file
3. create Activation Token arrow function
4. In side the arrow function Generate random 4 digit number as activation code
5. Sign the Activation Code with jwt
6. return the the signed token and activation code

```js
import jwt from "jsonwebtoken";
import "dotenv/config.js";

//create Activation Token
export const createEmailActivationToken = (id) => {
  //Generate random 4 digit number
  const EmailActivationCode = Math.floor(
    1000 + Math.random() * 9000
  ).toString();

  //Sign the Activation Code with jwt
  const EmailActivatioinToken = jwt.sign(
    {
      id,
      EmailActivationCode,
    },
    process.env.JWT_EMAIL_ACTIVATION_SECRET,
    {
      expiresIn: process.env.JWT_EMAIL_ACTIVATION_EXPIRES,
    }
  );

  return { EmailActivationCode, EmailActivatioinToken };
};
```

## 1.2. Create email format to send OTP

1. In mails folder create header.ejs file inside it create header welcome text by using html and css

```html
<div
  style="
    background: linear-gradient(90deg, #1a2e66, #7f00ff);
    padding: 30px 0;
    text-align: center;
    font-family: 'Poppins', Arial, sans-serif;
    color: white;
  "
>
  <img
    src="https://yourdomain.com/path-to-your-logo.png"
    alt="ShopOrbit Logo"
    style="height: 60px; margin-bottom: 10px"
  />
  <h1 style="margin: 0; font-size: 28px">
    Welcome to <span style="color: #f37022">ShopOrbit</span>
  </h1>
  <p style="margin: 5px 0 0; font-size: 16px">Every product delivered to you</p>
</div>
```

2. In mails folder create footer.ejs file inside it create a footer element by using html and css

```html
<div
  style="
    background: linear-gradient(90deg, #1a2e66, #7f00ff);
    padding: 30px 0;
    text-align: center;
    font-family: 'Poppins', Arial, sans-serif;
    color: #ffffff;
    font-size: 14px;
  "
>
  <p style="margin: 0 0 8px">Have questions? We're here to help!</p>
  <p style="margin: 0">
    Contact us at
    <a
      href="mailto:support@shoporbit.com"
      style="color: #f37022; text-decoration: none"
    >
      support@shoporbit.com
    </a>
  </p>
</div>
```

3. In mails folder create welcome.ejs file inside it combine the two the above files and body elements

```html
<%- include('./header.ejs') %>

<div
  style="
    margin: 0 auto;
    max-width: 720px;
    padding: 30px 0;
    font-family: 'Poppins', Arial, sans-serif;
    color: #1c1c1e;
  "
>
  <p style="font-size: 16px">Hello <%= name %>,</p>

  <p style="font-size: 16px; line-height: 1.6">
    Welcome to <strong>ShopOrbit</strong>! Thank you for registering. To
    activate your account, please use the following activation code:
  </p>

  <h2
    style="
      font-size: 28px;
      color: #f37022;
      background-color: #f8f8f8;
      padding: 12px 24px;
      border-radius: 8px;
      text-align: center;
      width: fit-content;
      margin: 20px auto;
    "
  >
    <%= message %>
  </h2>

  <p style="font-size: 16px; line-height: 1.6; text-align: center">
    Please enter this code on the activation page within the next 10 minutes.
  </p>

  <p
    style="
      font-size: 14px;
      color: #666666;
      line-height: 1.6;
      text-align: center;
    "
  >
    If you did not register for a ShopOrbit account, you can safely ignore this
    email.
  </p>
</div>

<%- include('./footer.ejs') %>
```

## 1.3 Using Google App Passwords for Nodemailer

If you're using Google with third-party apps like Nodemailer, direct login with your email password may fail due to enhanced security policies. Instead, generate an App Password.

### To generate an App Password on Google Account:

1. Go to Manage Your Google Account ![Manage Your Google Account](/Images/Google%20Account/Manage%20Your%20Google%20acount.png)
2. Then Go to Google Account Settings, Under "Security section" enable 2-Step Verification.
   ![](/Images/Google%20Account/2.png)

   ![](/Images/Google%20Account/3.png)

   ![](/Images/Google%20Account/5.png)

   ![](/Images/Google%20Account/6.png)

3. After enabling 2-Step Verification, return to the Security section in your Google account. Look for App Passwords option under Security section, if not found there, search it as App Passwords in Search bar in Google account ![app Password](/Images/Google%20Account/1.png)

4. If promoted to Sign in to your account again to verify your identity, go head verify yourself.
5. Type your project name in App name field and click on create.
   ![](/Images/Google%20Account/7.png)

   ![](/Images/Google%20Account/8.png)

6. Copy the generated 16-character password. This is your App Password.
7. Use the generated app password in your `.env` file for Nodemailer.

## 1.4 To Send the activation email to user

### Dependencies

1. Built-in Node.js modules: path, url
2. Nodemailer: For sending emails
3. Dotenv: For environment variable management
4. Ejs: For rendering email templates

### 1. Built-in Node.js modules: path, url

#### In Node.js when using ECMAScript (ES) modules.

`import path from "path";` :- This line imports the built-in Node.js path module, which provides utilities for working with file and directory paths.

`import { fileURLToPath } from "url"; `:- This line imports the fileURLToPath function from the built-in Node.js url module. This function is used to convert a file:// URL into a platform-specific file path.

`import { dirname } from "path"; `:- This line specifically imports the dirname function from the path module. This function extracts the directory name from a given path.

`const __filename = fileURLToPath(import.meta.url);` :- `import.meta.url` is a special property available in ES modules that provides the full URL of the current module file (e.g., file:///path/to/your/file.js).

`fileURLToPath(import.meta.url)` converts this URL into a standard file path string (e.g., /path/to/your/file.js), which is then assigned to the `__filename` constant. This \*\*filename effectively serves the same purpose as the \_\_filename global variable in CommonJS modules.

`const __dirname = dirname( __filename); `:-

- dirname(\_\_filename) uses the dirname function from the path module to extract the directory part from the \*\*filename path.
- The resulting directory path is assigned to the \*\*dirname constant, which then functions similarly to the \*\*dirname global variable found in CommonJS modules.

  In summary, this code provides a workaround to access the current file's full path ( \_\_filename) and its directory path ( \_\_dirname) within an ES module environment, as these global variables are not directly available in ES modules like they are in CommonJS.

### 2. Nodemailer: For sending emails

##### 2.1 To send email we use nodemailer package.

`Nodemailer` is a module for Node.js applications to allow easy as cake email sending.

This module provides functionality for sending emails using Nodemailer with EJS templates. It's designed to be used in a Node.js application for sending templated emails with dynamic content.

Nodemailer is a popular Node.js module for sending emails. It simplifies the process of sending emails from Node.js applications by providing a straightforward API and supporting various email features and transport methods. Key features include security, Unicode support, and the ability to send different types of emails (plain text, HTML, with attachments).

##### 2.2 Nodemailer Installation:

You can install it using npm: npm install nodemailer

##### 2.3 Nodemailer Transporter:

A transporter object is created to handle the email sending process. It requires configuration with details like the email service (e.g., Gmail, Outlook), authentication credentials (user, password or OAuth2), and optional settings.

##### 2.4 Message Options:

The mailOptions object specifies the email details, including sender, recipients (to, cc, bcc), subject, and content (text and/or HTML).

##### 2.5 Sending Emails:

The transporter.sendMail() method sends the email, taking the mailOptions and a callback function to handle success or errors.

##### 2.6 Security:

Nodemailer emphasizes security and avoids Remote Code Execution (RCE) vulnerabilities. It's recommended to use environment variables for sensitive information like credentials.

##### 2.7 OAuth2 Authentication:

For services like Gmail, OAuth2 authentication is recommended for enhanced security. This involves setting up an OAuth 2.0 client ID and secret, and obtaining a refresh token.

##### 2.8 Gmail Specifics:

Gmail requires 2-Step Verification and App Passwords for use with Nodemailer.

##### 2.9 Error Handling:

Nodemailer provides error handling through the callback function when sending emails

##### 2.10 Nodemailer Transport Configuration

```js
 nodemailer.createTransport({
  host: process.env.SMTP_HOST,
  port: parseInt(process.env.SMTP_PORT || "587"),
  service: process.env.SMTP_SERVICE,
  auth: {
    user: process.env.SMTP_MAIL,
    pass: process.env.SMTP_PASSWORD,
  },
});"
```

This code creates a transporter object using Nodemailer, which is essentially a connection to an SMTP (Simple Mail Transfer Protocol) server that will be used to send emails. Here's a detailed breakdown:

##### 2.11 Core Components

`nodemailer.createTransport()` :-
This is the main method from the Nodemailer library that creates a reusable mail transporter object. All email sending operations will use this configured transporter.

##### 2.12 Configuration Options

` 1. host`

```js
host: process.env.SMTP_HOST;
```

-Specifies the SMTP server hostname (e.g., "smtp.gmail.com" or "smtp.mail.yahoo.com")
-Retrieved from environment variables for security (keeps credentials out of code)
-Example value might be: "smtp.gmail.com"

`2. port`

```js
port: parseInt(process.env.SMTP_PORT || "587");
```

- Defines the port number for the SMTP connection
- Uses a fallback value of "587" if SMTP_PORT isn't set in environment
- parseInt() converts the string to a number (SMTP requires numeric port)
- Port 587 is the standard port for SMTP submission with TLS encryption

* Other common ports:

  - 465 for SMTPS (deprecated but still used)
  - 25 for unencrypted SMTP (not recommended)

- Port Selection:

  - Using port 587 (with STARTTLS) is more secure than port 25

  - Port 465 (SMTPS) is also secure but less commonly used now

`3. service`

```js
service: process.env.SMTP_SERVICE;
```

- Optional but recommended for well-known providers

- Can be used instead of host and port for popular services

* Nodemailer knows default settings for services like:

  - "Gmail"

  - "Yahoo"

  - "Hotmail"

  - "Outlook"

  - "iCloud"

* If both service and host/port are provided, service takes precedence
* Example usage in .env

```js
SMTP_SERVICE = Gmail;
```

or in nodemailer

```js
{
  service: "Gmail",
}
```

`4. auth`

```js
      auth: {
        user: process.env.SMTP_MAIL,
        pass: process.env.SMTP_PASSWORD,
      }
```

- Contains authentication credentials for the SMTP server

- user: The email account username (typically your email address )

- pass: The password or app-specific password for the account of your email

- Both values are securely loaded from environment variables

* For Gmail, the pass value you might need to:

  - Use an "App Password" if 2FA is enabled

  - Allow "Less secure apps" if using basic authentication, other than app password

`Example Configuration`

```js
{
    host: "smtp.gmail.com",
    port: 587,
    service: "Gmail",
    auth: {
          user: "your.email@gmail.com",
          pass: "your-app-specific-password"
       }
}
```

### 3. Dotenv: For environment variable management

`Example Configuration`

For a Gmail account in .env file,

```js
    SMTP_HOST=smtp.gmail.com
    SMTP_PORT=587
    SMTP_SERVICE=Gmail
    SMTP_MAIL=your.email@gmail.com
    SMTP_PASSWORD=your-app-password-you-get-it-from-Google
```

### 4. Ejs: For rendering email templates

#### What is EJS

EJS, or Embedded JavaScript templating, is a simple templating language that lets you generate HTML markup with plain JavaScript. It allows you to embed JavaScript code directly within HTML files, making it easier to create dynamic web pages.

#### What it does:

EJS enables you to create HTML templates where you can insert dynamic content and logic written in JavaScript.

#### How it works:

EJS uses special tags to identify JavaScript code within HTML. These tags can be used to output variables, control flow (like loops and conditionals), and even include other templates.

#### Use cases:

EJS is commonly used in Node.js applications, especially with frameworks like Express.js, to generate dynamic web pages by combining static HTML with data from the server.

#### Ejs Methodes ejs.renderFile() and ejs.render()

Both methods are used for rendering EJS templates, but they work differently

##### 1. ejs.renderFile()

- Purpose: Renders an EJS template stored in a file.
- Usage: Best when templates are stored in separate .ejs files.

`Syntax:`

With callback function:

```js
ejs.renderFile(filename, data, options, callback);
```

or with async/await :

```javascript
const html = await ejs.renderFile(filename, data, options);
```

Parameters:-

- filename: The path to the EJS template file to be rendered.
- data: An object containing the data to be passed to the template. This data can then be accessed and used within the EJS file to dynamically generate content.
- options: An optional object for configuring rendering options (e.g., caching, filename for includes).
- callback: A function that will be called once the rendering is complete, receiving either an error object or the rendered HTML string.

`Key Features:`

- Works directly with file paths.
- Supports asynchronous operations (better for production).
- Automatically reads the file content.
- Can use caching for better performance.

`Example:`

```javascript
const html = await ejs.renderFile(path.join(__dirname, "templates/email.ejs"), {
  name: "John",
});
```

##### 2. ejs.render()

- Purpose: Renders an EJS template from a string (not a file).
- Usage: Best for inline templates or dynamically generated strings.

`Syntax:`

With callback function

```javascript
ejs.render(templateString, data, options, callback);
```

or with async/await:

```javascript
const html = await ejs.render(templateString, data, options);
```

`Key Features:`

- Works with raw template strings (no file needed).
- Synchronous by default (unless using async option).
- Faster for small, dynamic templates.

`Example:`

```javascript
const template = `<h1>Hello <%= name %>!</h1>`;
const html = ejs.render(template, { name: "John" });
```

### In side utils folder create `sendEmail.js` file, inside it write eamil sending code

```js
import nodemailer from "nodemailer";
import ejs from "ejs";
import path from "path";
import { fileURLToPath } from "url";
import { dirname } from "path";
import "dotenv/config";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const transporter = nodemailer.createTransport({
  host: process.env.SMTP_HOST,
  port: parseInt(process.env.SMTP_PORT || "587"),
  service: process.env.SMTP_SERVICE,
  auth: {
    user: process.env.SMTP_MAIL,
    pass: process.env.SMTP_PASSWORD,
  },
});

const sendEmail = async (options) => {
  const { email, subject, message, name, ejsUrl } = options;

  try {
    // Render EJS template
    const data = await ejs.renderFile(
      path.join(__dirname, `../mails/${ejsUrl}`),
      { email, message, name }
    );

    // Send email
    const mailOptions = {
      from: process.env.SMTP_MAIL,
      to: email,
      subject,
      html: data,
    };

    await transporter.sendMail(mailOptions);

    console.log(`Email sent successful to ${email} `);

    return { success: true, email };
  } catch (error) {
    console.error("Email sending failed:", error);
    throw error; // Re-throw to let caller handle it
  }
};

export default sendEmail;
```

## Now we are back to Register User Controller

To finish step 5, 6 and 7

### In step 5. Generate email verification code/token.

We already generated Verification code inside `utils` folder/generateTokens.js, then import the method in side register user controller file.

```js
//import modules
import jwt from "jsonwebtoken";
import crypto from "crypto";

//import local files
import User from "../models/UserModel.js";
import ErrorHandler from "../utils/errorHandler.js";
import tryCatchAsyncErrorHandlers from "../middleware/tryCatchAsyncErrorHandlers.js";
import { createEmailActivationToken } from "../utils/generateTokens.js";
import sendEmail from "../utils/sendEmail.js";

// @desc    Register user
// @route   POST /api/v1/user/register
// @access  Public
export const registerUser = tryCatchAsyncErrorHandlers(
  async (req, res, next) => {
    // 1. Get user input from req.body (name, email, password).
    const { name, email, password } = req.body;

    //2. Check if a user with the given email already exists in the database.
    const isUserExist = await User.findOne({ email });

    //3. If user exists, throw a 400 error: "User already exists with this email."
    if (isUserExist) {
      return next(
        new ErrorHandler("User already exists with this email.", 400)
      );
    }

    //4. If user does not exist:- Create new user in MongoDB.
    const user = await User.create({
      name,
      email,
      password,
      provider: "Local",
    });

    //5. Generate email verification code/token.
    const emailActivationToken = createEmailActivationToken(user._id);
    const { EmailActivationCode } = emailActivationToken;
    const message = EmailActivationCode;
    const ejsUrl = `welcome.ejs`;

    //6. Send activation email to user's email with verification link or code.
    try {
      await sendEmail({
        email,
        subject: "Verify your email",
        message,
        name,
        ejsUrl,
      });

      //7. Return status 201 with a message: "User registered successfully. Please verify your email.
      res.status(201).json({
        success: true,
        message: `Please check your email ${user.email} to activate your account!`,
        EmailActivatioinToken: emailActivationToken.EmailActivatioinToken,
      });
    } catch (error) {
      return next(new ErrorHandler(error.message, 400));
    }
  }
);
```

# 2. Create User Route

Now we have register user controller function and we can now add this register user controller function to route file. Inside routes folder create `userRoute.js` file. In this file write ‚úçÔ∏è the following code.

```js
import express from "express";
import { registerUser } from "../controllers/UserController.js";

const userRouter = express.Router();

// Create user route
userRouter.post("/register", registerUser);

export default userRouter;
```

# 3. Adding user Route middleware to app.js file

Inside app.js file. In this file write ‚úçÔ∏è the following code.

```js
import userRouter from "./routes/userRoute.js";

//routes Middlewares
app.use("/api/v1/user", userRouter);
```

# 4. Verify User Email

Verifying a user's email after registering to an app refers to a security and validation process designed to confirm that the email address provided during registration is legitimate and accessible by the user who registered it. This process typically involves the following steps:

`Sending a Confirmation Email:`

After a user registers, the app automatically sends an email to the address they provided. This email usually contains a unique a one-time verification code.

`User Action:`

The user must then access their email inbox, locate the confirmation email, and enter the provided code back into the app.

`Account Activation/Verification:`

Once the user completes the required action ( entering the code), the app confirms that the email address is valid and owned by the user. This typically activates their account or grants them full access to the app's features.

## 4.1 User Activation/Verification requirements

1. Get activation code and activation token from req.body,
2. Verify activation token by using jwt.verify
3. If the activation token not valid , throw the error to the client
4. If the activation token is valid, check if activation code match which is decoded from activation token.
5. If not match , throw the error to the client
6. If match, find user in DB by using its ID, which is decoded from activation token.
7. If user not exist in DB, throw the error to the client
8. If user exist and isVerified field is true , throw the error to the client stating that "Your email is verified, Please login"
9. If user exist and isVerified field is false, update users' DB `isVerified: true` and then send success message to client.

## 4.2 User Activation/Verification Code

Inside `userController.js` file, write ‚úçÔ∏è the following code to Activate/Verify user.

```js

```

## 4.3 Add Verify User Route to user Route (userRoute.js)

Now we have activate user controller function and we can now add this activate user controller function to route file.

Inside `userRoute.js` file, write ‚úçÔ∏è the following code.

```js

```

## 2. User Login Requirements

1. Get email and password from `req.body`.
2. Validate both fields are provided.
3. Find user by email, and include password in query (`select: +password`).
4. If user not found or password doesn't match, return 401: "Invalid credentials".
5. Check if user is banned or not verified.
6. Generate access and refresh JWT tokens.
7. Set refresh token in HttpOnly cookie.
8. Return 200 with access token and user data.

## 3. Refresh Token Requirements

1. Get refresh token from cookies.
2. If missing, return 401: "No refresh token found".
3. Verify token and generate new access token.
4. Return new token and updated user info.

## 4. Logout Requirements

1. Clear refresh token cookie.
2. Return 200 with message: "Logged out successfully".

## 5. Email Verification Requirements

1. Get verification token from request.
2. Find user by token or email.
3. If invalid/expired, return 400.
4. Set `isVerified = true`, clear token.
5. Return 200: "Email verified successfully".

## 6. Forgot Password Requirements

1. Get email from `req.body`.
2. Check if user exists.
3. Generate reset token and expiry.
4. Save to DB and send email with reset link.
5. Return 200 with message.

## 7. Reset Password Requirements

1. Get token and new password from request.
2. Find user by token and validate expiry.
3. Hash new password, update DB.
4. Return 200: "Password updated successfully".

## 8. Get User Profile Requirements

1. Use `req.user.id` to fetch user profile.
2. Return 200 with user data.

## 9. Update Profile Requirements

1. Get updated fields from `req.body`.
2. Update DB, verify if email changed.
3. Return 200 with updated user.

## 10. Change Password Requirements

1. Get old and new password.
2. Verify old password.
3. Hash and update new password.
4. Return 200.

## 11. Wishlist Requirements

1. Get productId.
2. Toggle add/remove from wishlist.
3. Return updated wishlist.

## 12. Address Management Requirements

- **Add/Update/Delete Address**
- Set default
- Return updated address list

```

```
